The previous techniques are applicable to this query but a few modificatons must take place. We cannot simply pass in the dates that each employee worked for a particular department. Instead we need to traverse each employee that has worked for that department. Once we have done that we have to combine the total of every emlpoyee per department periods into a date pairs that correspond to every one. This results in large number of tuples which is the cause of the long running time. With all the periods sliced up we then can apply the same techniques as Query 1.7 and Query 1.6. The first four steps in util:getDeptRisHistory are very similiar to Query 1.7 and Query 1.6. util:alls Is where the deviation begins. In this function we are obtaining the valid salary tuple for an employee for a given department. Given that we obtain the distinct values (util:emps) and we pass this along to util:rise. This function will traverse each employee. If an employee's salary for one of his/her date ranges is greater than or equal to his/her previous than we place a 1 in a tuple, otherwise we place a 0. Note that we place a 1 for the first time period that an employee works for a department (assumed to be rising for that department, even though the possibility exists that the employee actually had a decrease in salary form a switched department). Now with tuples organized by employee for department describing the rising values we obtain the distinct dates for each employee that we then must combine into a giant set of all employees per department. This step is done in util:riseDates. The problem then is formed exactly the same as Query 1.7 and Query 1.6 the only difference being the aggregate is determing whether or not the current tuple is a 1 or 0. 