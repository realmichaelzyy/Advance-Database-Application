The first task here was to get all the date periods that an employee was working for a particular department for each department. Once we knew all the date periods we had to find the count of employees for each date period for each department. Then we had to coalesce the date periods (combine adjacent date periods with the same count into one date period) and display the results. It is worth examining in detail the above XQuery since the same technique is applied to next two queries. The first step is to obtain all dates for which an employee was working for a particular department. The function call to util:empDates will do this. With the employee periods we then pair up all dates minus the first and last with it's right neighbor (util:datePairs). We then format this data (util:extract) and then for each period get the count of employees. This will obtain what we want but there will be many adjacent tuples with the same count. To coalesce these then we devise an approach of indexing the tuples (util:colid) and then traversing each tuple and "walking backwards" in the traversal from each tuple to find a tuple that contains a different value. Once we find that different value tuple we set the unique id of the current tuple to the column id of the different value tuple plus one. The function that executes this is util:uncolid. Walking backwards is in quotes above because we actually do this in a binary search to prevent recursion overflow. A problem occurs using binary search when we find a tuple that is different we search the next tuple to see if it is the expected value, but this can cause errors if the tuples are not ordered (which is not guaranteed). To solve this we call a function (util:check) which checks to make sure that all tuples from a given start and end index (column id) are the same. With the columns coalesced returning the results is a matter of simple formatting. 